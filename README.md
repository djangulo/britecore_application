# Denis Angulo's britecore application project

Hello, and welcome to my application project.

This project was built with the following technologies:

* django
* django-rest-framework
* Vue.js
* aws-cli
* pipenv

## TOC<a name="toc"></a>

- [Links to deployed versions](#links)
    - [AWS Lambda](#aws-lambda)
    - [AWS EC2 (with docker)](#aws-ec2)
- [Approach](#approach)
    - [Approach deliverables](#approach-deliverables)
- [Deployment](#deployemnt)
    - [Before deploying](#before-deploying)
        - [Configuring AWS cli](#configure-aws-cli)
        - [Pipenv](#configure-pipenv)
    - [Deploy to AWS-Lambda](#deploy-aws-lambda)
    - [Deploy to AWS-EC2](#deploy-aws-ec2)
- [Deliverable summary](#deliverables)

## Links to the deployed version<a name="links"></a>

#### AWS-Lambda<a name="aws-lambda"></a>

https://bkw3yst1yb.execute-api.us-east-2.amazonaws.com/prod


#### AWS EC2<a name="aws-ec2"></a>

http://18.191.189.208


[Back to TOC](#toc)

---

## My approach<a name="approach"></a>

I decided to use Django Rest Framework, as it keeps it pretty simple to create a maintainable API.

I modeled the two tables rather straightforwardly (by Django standards), by creating a RiskType model and a FieldType model, and relating the FieldType to the RiskType via a foreign key. Their arranged as follows:

RiskType model has:

- A `name` field (CharField)
- A `description` field (CharField)

FieldType model has:

- `name` field (CharField)
- `data_type` field, IntegerField with choices
- `help_text` field, CharField (seemed appropriate as these will emulate form fields)
- `number_of_fields`, convenience field for Enum types. I'm well aware this is not the best approach to having Enums with multiple form fields (a custom model field using MultiWidget is the way to go, in my opinion). But, since I implemented all my forms with JavaScript (Vue.js, more precisely), MultiWidget was not an option. This approach seemed to offer the best benefits for the scope and time constraints of this project.
- `risk` field, not-required, nullable foreign key field to the RiskType model

I left the foreign key un-required (blank=True) and nullable, that way It allows me to hit the API and create FieldType objects without having to attach it to a RiskType object.

For the frontend, I embedded a Vue.js instance into a TemplateView (instanced directly in `britecore_application/urls.py`), and performed all API calls and form rendering through the Vue app.

The full implementation (what is implied by the description) is that this will be a dynamic model generator, where the Django API and models act as metadata tables, who in turn are pointed programmatically to another database containing the actual tables for the forms generated by Vue and the API.

I understand this is a concept project, but I had to fully implement the description above, I would create an AWS DynamoDB instance (or any other NOSQL database), with endpoints that accept AJAX calls from our Vue instance. NOSQL offers more flexibility when it comes to dynamic models like this one (SQL schemas can be rather rigid, specially if scaled).

#### Deliverables<a name="approach-deliverables"></a>


- README that describes approach and deployment
    - You're reading it!
- Links to the deployed version of project:
    - See [links](#links)
- Bonus points for orchestrating with AWS Cloudformation
    - I did not see the need of orchestrating the creation of say, an EC2 instance when the AWS-lambda deployment is serverless. If you would accept it, I would like to offer the [docker deployment](#deploy-docker) instead.
- Mega Bonus points for hosting in AWS lambda with Zappa
    - See [the AWS-Lambda deployment section](#deploy-lambda)

For details on deployment, see the [deployment](#deployment) section.

[Back to TOC](#toc)

---

# Deployment<a name="deployment"></a>

## Before deploying<a name="before-deploying"></a>

There are several steps to take prior to installation:

#### Configure aws-cli<a name="configure-aws-cli"></a>

Create a dir in ~/.aws/credentials with the following structure:

    [default]
    aws_access_key_id=YOURACCESSKEY
    aws_secret_access_key=YOURSECRETKEY

in order to not have to enter them for every call to aws-cli. You will also need to update 
`deploy/zappa_settings_template` "vpc_config, to contain your own `SubnetIds` and `SecurityGroupIds`

#### Pipenv<a name="configure-pipenv"></a>

This project requires pipenv to deploy, so please install pipenv. Quoting the official docs:

If you're on MacOS, you can install Pipenv easily with Homebrew:

    $ brew install pipenv

Or, if you're using Fedora 28:

    $ sudo dnf install pipenv

You could otherwise install it directly with pip

    $ pip install --user pipenv

If all else fails, you could do a direct download:

    $ curl https://raw.githubusercontent.com/kennethreitz/pipenv/master/get-pipenv.py | python

Keep in mind that some distributions alias python 2 as python, and python3 for python 3.


## Deploy to AWS-Lambda<a name="deploy-lambda"></a>

Once pipenv is installed, is as simple as running the script at `deploy/zappa_deploy.sh`.

**Prior** to running the script, you need to set the environment variables SQL_PASSWORD
and SECRET_KEY, the following snippets should do it

    $ export SQL_PASSWORD=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 50; echo '')
    $ export SECRET_KEY=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 50; echo '')

This deployment takes more time, as it needs to wait for the RDS Postgres instance to be available before proceeding to deploy the django app.

Then the script will:

* run pipenv install
* create an AWS db-instance through the cli
* ping the database (through aws rds describe-db-instances) to check if the endpoint is       available
* when ready, it will proceed to deploy with zappa
* once deployed, it will migrate and create some sample risk policies to display

## Deploy to AWS EC2 with docker<a name="deploy-docker"></a>

Requirements:

* docker >= 18.09
* docker-compose >= 1.23.1
* docker-machine >= 0.16.0

Same as before, setup `~/.aws/credentials` appropriately. Then run `deploy/docker_deploy.sh`.

This script will do the following:

    $ docker-machine create --driver amazonec2 --amazonec2-open-port 8000 --amazonec2-region us-east-2 britecore-app

Connect the machine as the active host:

    $ eval $(docker-machine env britecore-app)

Then run 

    $ docker-compose up --build -d

The instance will be running at the public IP of the docker-machine (you can check with `docker-machine ls`).

## Un-deploy

To take down the app:

* If deployed with AWS/Zappa, run `pipenv run zappa undeploy -y`
* If you used Docker, run `docker-machine rm -y britecore-app`

